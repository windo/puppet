# vim: syntax=ruby

# the parser

class Puppet::Parser::Parser

token STRING DQPRE DQMID DQPOST
token LBRACK  RBRACK LBRACE RBRACE SYMBOL FARROW COMMA TRUE
token FALSE EQUALS APPENDS LESSEQUAL NOTEQUAL DOT COLON LLCOLLECT RRCOLLECT
token QMARK LPAREN RPAREN ISEQUAL GREATEREQUAL GREATERTHAN LESSTHAN
token IF ELSE IMPORT DEFINE ELSIF VARIABLE CLASS INHERITS NODE BOOLEAN
token NAME SEMIC CASE DEFAULT AT LCOLLECT RCOLLECT CLASSNAME CLASSREF
token NOT OR AND UNDEF PARROW PLUS MINUS TIMES DIV LSHIFT RSHIFT UMINUS
token MATCH NOMATCH REGEX

prechigh
  right NOT
  nonassoc UMINUS
  left  MATCH NOMATCH
  left  TIMES DIV
  left  MINUS PLUS
  left  LSHIFT RSHIFT
  left  NOTEQUAL ISEQUAL
  left  GREATEREQUAL GREATERTHAN LESSTHAN LESSEQUAL
  left  AND
  left  OR
preclow

rule
program:    statements {
  if val[0]
    # Make sure we always return an array.
    if val[0].is_a?(Expression::ArrayConstructor)
      if val[0].children.empty?
        result = nil
      else
        result = val[0]
      end
    else
      result = aryfy(val[0])
    end
  else
    result = nil
  end
}
  | nil

statements:   statement
  | statements statement {
    if val[0] and val[1]
    if val[0].instance_of?(Expression::ArrayConstructor)
      val[0].push(val[1])
      result = val[0]
    else
      result = ast Expression::ArrayConstructor, :children => [val[0],val[1]]
    end
  elsif obj = (val[0] || val[1])
    result = obj
  else result = nil
  end
}

# The main list of valid statements
statement:    resource
  | virtualresource
  | collection
  | assignment
  | casestatement
  | ifstatement
  | import
  | fstatement
  | definition
  | hostclass
  | nodedef
  | resourceoverride
  | append

fstatement:   NAME LPAREN funcvalues RPAREN {
  args = aryfy(val[2])
  result = ast Expression::Function,
    :name => val[0][:value],
    :line => val[0][:line],
    :arguments => args,
    :ftype => :statement
}
| NAME LPAREN funcvalues COMMA RPAREN {
  args = aryfy(val[2])
  result = ast Expression::Function,
    :name => val[0][:value],
    :line => val[0][:line],
    :arguments => args,
    :ftype => :statement
}            | NAME LPAREN RPAREN {
  result = ast Expression::Function,
    :name => val[0][:value],
    :line => val[0][:line],
    :arguments => Expression::ArrayConstructor.new({}),
    :ftype => :statement
}
  | NAME funcvalues {
    args = aryfy(val[1])
    result = ast Expression::Function,
    :name => val[0][:value],
    :line => val[0][:line],
    :arguments => args,
    :ftype => :statement
}

funcvalues:       namestring
  | resourceref
  | funcvalues COMMA namestring {
    result = aryfy(val[0], val[2])
    result.line = @lexer.line
    result.file = @lexer.file
}
  | funcvalues COMMA resourceref {
    unless val[0].is_a?(Expression::ArrayConstructor)
    val[0] = aryfy(val[0])
  end

  val[0].push(val[2])

  result = val[0]
}

# This is *almost* an rvalue, but I couldn't get a full
# rvalue to work without scads of shift/reduce conflicts.
namestring:       name
  | variable
  | type
  | boolean
  | funcrvalue
  | selector
  | quotedtext
  | hasharrayaccesses
  | CLASSNAME {
    result = ast Expression::Name, :value => val[0][:value]
      }

resource:       classname LBRACE resourceinstances endsemi RBRACE {
  @lexer.commentpop
  array = val[2]
  array = [array] if array.instance_of?(Expression::ResourceInstance)
  result = ast Expression::ArrayConstructor

  # this iterates across each specified resourceinstance
  array.each { |instance|
    raise Puppet::Dev, "Got something that isn't an instance" unless instance.instance_of?(Expression::ResourceInstance)
    # now, i need to somehow differentiate between those things with
    # arrays in their names, and normal things

      result.push ast(
        Expression::Resource,
      :type => val[0],
      :title => instance[0],

      :parameters => instance[1])
  }
}           | classname LBRACE params endcomma RBRACE {
  # This is a deprecated syntax.
  error "All resource specifications require names"
}           | classref LBRACE params endcomma RBRACE {
  # a defaults setting for a type
  result = ast(Expression::ResourceDefaults, :type => val[0], :parameters => val[2])
}

# Override a value set elsewhere in the configuration.
resourceoverride:     resourceref LBRACE anyparams endcomma RBRACE {
  @lexer.commentpop
  result = ast Expression::ResourceOverride, :object => val[0], :parameters => val[2]
}

# Exported and virtual resources; these don't get sent to the client
# unless they get collected elsewhere in the db.
virtualresource:  at resource {
  type = val[0]

  if (type == :exported and ! Puppet[:storeconfigs]) and ! Puppet[:parseonly]
    Puppet.warning addcontext("You cannot collect without storeconfigs being set")
  end

  error "Defaults are not virtualizable" if val[1].is_a? Expression::ResourceDefaults

  method = type.to_s + "="

  # Just mark our resources as exported and pass them through.
  if val[1].instance_of?(Expression::ArrayConstructor)
    val[1].each do |obj|
      obj.send(method, true)
    end
  else
    val[1].send(method, true)
  end

  result = val[1]
}

at:   AT { result = :virtual }
  | AT AT { result = :exported }

# A collection statement.  Currently supports no arguments at all, but eventually
# will, I assume.
collection:     classref collectrhand LBRACE anyparams endcomma RBRACE {
  Puppet.warning addcontext("Collection names must now be capitalized") if val[0] =~ /^[a-z]/
  type = val[0].downcase
  args = {:type => type}

  if val[1].is_a?(Expression::CollExpr)
    args[:query] = val[1]
    args[:query].type = type
    args[:form] = args[:query].form
  else
    args[:form] = val[1]
  end
  if args[:form] == :exported and ! Puppet[:storeconfigs] and ! Puppet[:parseonly]
    Puppet.warning addcontext("You cannot collect exported resources without storeconfigs being set; the collection will be ignored")
  end
  args[:override] = val[3]
  result = ast Expression::Collection, args
}
  | classref collectrhand {
    if val[0] =~ /^[a-z]/
    Puppet.warning addcontext("Collection names must now be capitalized")
  end
  type = val[0].downcase
  args = {:type => type }

  if val[1].is_a?(Expression::CollExpr)
    args[:query] = val[1]
    args[:query].type = type
    args[:form] = args[:query].form
  else
    args[:form] = val[1]
  end
  if args[:form] == :exported and ! Puppet[:storeconfigs] and ! Puppet[:parseonly]
    Puppet.warning addcontext("You cannot collect exported resources without storeconfigs being set; the collection will be ignored")
  end
  result = ast Expression::Collection, args
}


collectrhand:     LCOLLECT collstatements RCOLLECT {
  if val[1]
    result = val[1]
    result.form = :virtual
  else
    result = :virtual
  end
}
  | LLCOLLECT collstatements RRCOLLECT {
    if val[1]
    result = val[1]
    result.form = :exported
  else
    result = :exported
  end
}

# A mini-language for handling collection comparisons.  This is organized
# to avoid the need for precedence indications.
collstatements:           nil
  | collstatement
  | collstatements colljoin collstatement {
    result = ast Expression::CollExpr, :test1 => val[0], :oper => val[1], :test2 => val[2]
}

collstatement:            collexpr
  | LPAREN collstatements RPAREN {
    result = val[1]
    result.parens = true
}

colljoin:                 AND { result=val[0][:value] }
  | OR  { result=val[0][:value] }

collexpr:                 colllval ISEQUAL simplervalue {
  result = ast Expression::CollExpr, :test1 => val[0], :oper => val[1][:value], :test2 => val[2]
  #result = ast Expression::CollExpr
  #result.push *val
}
  | colllval NOTEQUAL simplervalue {
    result = ast Expression::CollExpr, :test1 => val[0], :oper => val[1][:value], :test2 => val[2]
    #result = ast Expression::CollExpr
    #result.push *val
}

colllval:                 variable
  | name

resourceinst:   resourcename COLON params endcomma {
  result = ast Expression::ResourceInstance, :children => [val[0],val[2]]
}

resourceinstances:   resourceinst
  | resourceinstances SEMIC resourceinst {
    if val[0].instance_of?(Expression::ResourceInstance)
    result = ast Expression::ArrayConstructor, :children => [val[0],val[2]]
  else
    val[0].push val[2]
    result = val[0]
  end
}

endsemi:      # nothing
  | SEMIC

undef:         UNDEF {
  result = ast Expression::Undef, :value => :undef
}

name:         NAME {
  result = ast Expression::Name, :value => val[0][:value], :line => val[0][:line]
}

type:         CLASSREF {
  result = ast Expression::Type, :value => val[0][:value], :line => val[0][:line]
}

resourcename:   quotedtext
  | name
  | type
  | selector
  | variable
  | array
  | hasharrayaccesses

assignment:     VARIABLE EQUALS expression {
  raise Puppet::ParseError, "Cannot assign to variables in other namespaces" if val[0][:value] =~ /::/
  # this is distinct from referencing a variable
  variable = ast Expression::Name, :value => val[0][:value], :line => val[0][:line]
  result = ast Expression::VarDef, :name => variable, :value => val[2], :line => val[0][:line]
}
  | hasharrayaccess EQUALS expression {
    result = ast Expression::VarDef, :name => val[0], :value => val[2]
}

append:     VARIABLE APPENDS expression {
  variable = ast Expression::Name, :value => val[0][:value], :line => val[0][:line]
  result = ast Expression::VarDef, :name => variable, :value => val[2], :append => true, :line => val[0][:line]
}

params:   # nothing
{
  result = ast Expression::ArrayConstructor
}
  | param { result = val[0] }
  | params COMMA param {
    if val[0].instance_of?(Expression::ArrayConstructor)
    val[0].push(val[2])
    result = val[0]
  else
    result = ast Expression::ArrayConstructor, :children => [val[0],val[2]]
  end
}

param:        NAME FARROW rvalue {
  result = ast Expression::ResourceParam, :param => val[0][:value], :line => val[0][:line], :value => val[2]
}

addparam:     NAME PARROW rvalue {
  result = ast Expression::ResourceParam, :param => val[0][:value], :line => val[0][:line], :value => val[2],
    :add => true
}

anyparam:     param
  | addparam

anyparams:   # nothing
{
  result = ast Expression::ArrayConstructor
}
  | anyparam { result = val[0] }
  | anyparams COMMA anyparam {
    if val[0].instance_of?(Expression::ArrayConstructor)
    val[0].push(val[2])
    result = val[0]
  else
    result = ast Expression::ArrayConstructor, :children => [val[0],val[2]]
  end
}

rvalues:      rvalue
  | rvalues comma rvalue {
    if val[0].instance_of?(Expression::ArrayConstructor)
    result = val[0].push(val[2])
  else
    result = ast Expression::ArrayConstructor, :children => [val[0],val[2]]
  end
}

simplervalue:       quotedtext
  | name
  | type
  | boolean
  | selector
  | variable

rvalue:       quotedtext
  | name
  | type
  | boolean
  | selector
  | variable
  | array
  | hash
  | hasharrayaccesses
  | resourceref
  | funcrvalue
  | undef

# We currently require arguments in these functions.
funcrvalue:   NAME LPAREN funcvalues RPAREN {
  args = aryfy(val[2])
  result = ast Expression::Function,
    :name => val[0][:value], :line => val[0][:line],
    :arguments => args,
    :ftype => :rvalue
}           | NAME LPAREN RPAREN {
  result = ast Expression::Function,
    :name => val[0][:value], :line => val[0][:line],
    :arguments => Expression::ArrayConstructor.new({}),
    :ftype => :rvalue
}

quotedtext: STRING       { result = ast Expression::String, :value => val[0][:value],                  :line => val[0][:line] }
  | DQPRE dqrval { result = ast Expression::Concat, :value => [ast(Expression::String,val[0])]+val[1], :line => val[0][:line] }

dqrval: expression dqtail { result = [val[0]] + val[1] }

dqtail: DQPOST        { result = [ast(Expression::String,val[0])]          }
  | DQMID dqrval  { result = [ast(Expression::String,val[0])] + val[1] }

boolean:    BOOLEAN {
  result = ast Expression::Boolean, :value => val[0][:value], :line => val[0][:line]
}

resourceref: NAME LBRACK rvalues RBRACK {
  Puppet.warning addcontext("Deprecation notice:  Resource references should now be capitalized")
  result = ast Expression::ResourceReference, :type => val[0][:value], :line => val[0][:line], :title => val[2]
}               | classref LBRACK rvalues RBRACK {
  result = ast Expression::ResourceReference, :type => val[0], :title => val[2]
}

ifstatement:      IF expression LBRACE statements RBRACE else {
  @lexer.commentpop
  args = {
    :test => val[1],
    :statements => val[3]
  }

  args[:else] = val[5] if val[5]

  result = ast Expression::IfStatement, args
}
  | IF expression LBRACE RBRACE else {
    @lexer.commentpop
    args = {
      :test => val[1],
      :statements => ast(Expression::Nop)
  }

  args[:else] = val[4] if val[4]

  result = ast Expression::IfStatement, args
}

else:             # nothing
  | ELSE LBRACE statements RBRACE {
    @lexer.commentpop
    result = ast Expression::Else, :statements => val[2]
}
  | ELSE LBRACE RBRACE {
    @lexer.commentpop
    result = ast Expression::Else, :statements => ast(Expression::Nop)
}

# Unlike yacc/bison, it seems racc
# gives tons of shift/reduce warnings
# with the following syntax:
#
# expression: ...
#            | expression arithop expressio { ... }
#
# arithop: PLUS | MINUS | DIVIDE | TIMES ...
#
# So I had to develop the expression by adding one rule
# per operator :-(

expression:   rvalue
  | expression MATCH regex {
    result = ast Expression::MatchOperator, :operator => val[1][:value], :lval => val[0], :rval => val[2]
}
  | expression NOMATCH regex {
    result = ast Expression::MatchOperator, :operator => val[1][:value], :lval => val[0], :rval => val[2]
}
  | expression PLUS expression {
    result = ast Expression::ArithmeticOperator, :operator => val[1][:value], :lval => val[0], :rval => val[2]
}
  | expression MINUS expression {
    result = ast Expression::ArithmeticOperator, :operator => val[1][:value], :lval => val[0], :rval => val[2]
}
  | expression DIV expression {
    result = ast Expression::ArithmeticOperator, :operator => val[1][:value], :lval => val[0], :rval => val[2]
}
  | expression TIMES expression {
    result = ast Expression::ArithmeticOperator, :operator => val[1][:value], :lval => val[0], :rval => val[2]
}
  | expression LSHIFT expression {
    result = ast Expression::ArithmeticOperator, :operator => val[1][:value], :lval => val[0], :rval => val[2]
}
  | expression RSHIFT expression {
    result = ast Expression::ArithmeticOperator, :operator => val[1][:value], :lval => val[0], :rval => val[2]
}
  | MINUS expression =UMINUS {
    result = ast Expression::Minus, :value => val[1]
}
  | expression NOTEQUAL expression {
    result = ast Expression::ComparisonOperator, :operator => val[1][:value], :lval => val[0], :rval => val[2]
}
  | expression ISEQUAL expression {
    result = ast Expression::ComparisonOperator, :operator => val[1][:value], :lval => val[0], :rval => val[2]
}
  | expression GREATERTHAN expression {
    result = ast Expression::ComparisonOperator, :operator => val[1][:value], :lval => val[0], :rval => val[2]
}
  | expression GREATEREQUAL expression {
    result = ast Expression::ComparisonOperator, :operator => val[1][:value], :lval => val[0], :rval => val[2]
}
  | expression LESSTHAN expression {
    result = ast Expression::ComparisonOperator, :operator => val[1][:value], :lval => val[0], :rval => val[2]
}
  | expression LESSEQUAL expression {
    result = ast Expression::ComparisonOperator, :operator => val[1][:value], :lval => val[0], :rval => val[2]
}
  | NOT expression {
    result = ast Expression::Not, :value => val[1]
}
  | expression AND expression {
    result = ast Expression::BooleanOperator, :operator => val[1][:value], :lval => val[0], :rval => val[2]
}
  | expression OR expression {
    result = ast Expression::BooleanOperator, :operator => val[1][:value], :lval => val[0], :rval => val[2]
}
  | LPAREN expression RPAREN {
    result = val[1]
}

casestatement:  CASE rvalue LBRACE caseopts RBRACE {
  @lexer.commentpop
  options = val[3]
  options = ast Expression::ArrayConstructor, :children => [val[3]] unless options.instance_of?(Expression::ArrayConstructor)
  result = ast Expression::CaseStatement, :test => val[1], :options => options
}

caseopts:     caseopt
  | caseopts caseopt {
    if val[0].instance_of?(Expression::ArrayConstructor)
    val[0].push val[1]
    result = val[0]
  else
    result = ast Expression::ArrayConstructor, :children => [val[0], val[1]]
  end
}

caseopt:        casevalues COLON LBRACE statements RBRACE {
  @lexer.commentpop
  result = ast Expression::CaseOpt, :value => val[0], :statements => val[3]
}               | casevalues COLON LBRACE RBRACE {
  @lexer.commentpop

    result = ast(
    Expression::CaseOpt,
    :value => val[0],

    :statements => ast(Expression::ArrayConstructor)
  )
}

casevalues:       selectlhand
  | casevalues COMMA selectlhand {
    if val[0].instance_of?(Expression::ArrayConstructor)
    val[0].push(val[2])
    result = val[0]
  else
    result = ast Expression::ArrayConstructor, :children => [val[0],val[2]]
  end
}

selector:     selectlhand QMARK svalues {
  result = ast Expression::Selector, :param => val[0], :values => val[2]
}

svalues:      selectval
  | LBRACE sintvalues endcomma RBRACE {
    @lexer.commentpop
    result = val[1]
}

sintvalues:   selectval
  | sintvalues comma selectval {
    if val[0].instance_of?(Expression::ArrayConstructor)
    val[0].push(val[2])
    result = val[0]
  else
    result = ast Expression::ArrayConstructor, :children => [val[0],val[2]]
  end
}

selectval:        selectlhand FARROW rvalue {
  result = ast Expression::ResourceParam, :param => val[0], :value => val[2]
}

selectlhand:  name
  | type
  | quotedtext
  | variable
  | funcrvalue
  | boolean
  | undef
  | DEFAULT {
    result = ast Expression::Default, :value => val[0][:value], :line => val[0][:line]
}
  | regex

# These are only used for importing, and we don't interpolate there.
qtexts:       quotedtext { result = [val[0].value] }
  | qtexts COMMA quotedtext {
    results = val[0] << val[2].value
}

import: IMPORT qtexts {
  val[1].each do |file|
    import(file)
  end

  result = Expression::ArrayConstructor.new(:children => [])
}

# Disable definition inheritance for now. 8/27/06, luke
#definition: DEFINE NAME argumentlist parent LBRACE statements RBRACE {
definition: DEFINE classname argumentlist LBRACE statements RBRACE {
  @lexer.commentpop
  newdefine classname(val[1]), :arguments => val[2], :code => val[4], :line => val[0][:line]
  @lexer.indefine = false
  result = nil

#}           | DEFINE NAME argumentlist parent LBRACE RBRACE {
}           | DEFINE classname argumentlist LBRACE RBRACE {
  @lexer.commentpop
  newdefine classname(val[1]), :arguments => val[2], :line => val[0][:line]
  @lexer.indefine = false
  result = nil
}

#hostclass: CLASS NAME argumentlist parent LBRACE statements RBRACE {
hostclass: CLASS classname argumentlist classparent LBRACE statements RBRACE {
  @lexer.commentpop
  # Our class gets defined in the parent namespace, not our own.
  @lexer.namepop
  newclass classname(val[1]), :arguments => val[2], :parent => val[3], :code => val[5], :line => val[0][:line]
  result = nil
}           | CLASS classname argumentlist classparent LBRACE RBRACE {
  @lexer.commentpop
  # Our class gets defined in the parent namespace, not our own.
  @lexer.namepop
  newclass classname(val[1]), :arguments => val[2], :parent => val[3], :line => val[0][:line]
  result = nil
}

nodedef: NODE hostnames nodeparent LBRACE statements RBRACE {
  @lexer.commentpop
  newnode val[1], :parent => val[2], :code => val[4], :line => val[0][:line]
  result = nil
}       |  NODE hostnames nodeparent LBRACE RBRACE {
  @lexer.commentpop
  newnode val[1], :parent => val[2], :line => val[0][:line]
  result = nil
}

classref:       CLASSREF { result = val[0][:value] }

classname:       NAME { result = val[0][:value] }
  | CLASSNAME { result = val[0][:value] }
  | CLASS { result = "class" }

# Multiple hostnames, as used for node names.  These are all literal
# strings, not Expression nodes.
hostnames:    nodename
  | hostnames COMMA nodename {
    result = val[0]
    result = [result] unless result.is_a?(Array)
    result << val[2]
}

nodename: hostname {
  result = ast Expression::HostName, :value => val[0]
}

hostname: NAME { result = val[0][:value] }
  | STRING { result = val[0][:value] }
  | DEFAULT { result = val[0][:value] }
  | regex

nil:    {
  result = nil
}

nothing:    {
  result = ast Expression::ArrayConstructor, :children => []
}

argumentlist: nil
  | LPAREN nothing RPAREN {
    result = nil
}
  | LPAREN arguments RPAREN {
    result = val[1]
    result = [result] unless result[0].is_a?(Array)
}

arguments:    argument
  | arguments COMMA argument {
    result = val[0]
    result = [result] unless result[0].is_a?(Array)
    result << val[2]
}

argument:     NAME EQUALS rvalue {
  Puppet.warning addcontext("Deprecation notice: must now include '$' in prototype")
  result = [val[0][:value], val[2]]
}
  | NAME {
    Puppet.warning addcontext("Deprecation notice: must now include '$' in prototype")
    result = [val[0][:value]]
}           | VARIABLE EQUALS rvalue {
  result = [val[0][:value], val[2]]
}           | VARIABLE {
  result = [val[0][:value]]
}

nodeparent:       nil
  | INHERITS hostname {
    result = val[1]
}

classparent:       nil
  | INHERITS classnameordefault {
    result = val[1]
}

classnameordefault: classname | DEFAULT

variable:     VARIABLE {
  result = ast Expression::Variable, :value => val[0][:value], :line => val[0][:line]
}

array:        LBRACK rvalues RBRACK {
  if val[1].instance_of?(Expression::ArrayConstructor)
    result = val[1]
  else
    result = ast Expression::ArrayConstructor, :children => [val[1]]
  end
}
  | LBRACK rvalues COMMA RBRACK {
    if val[1].instance_of?(Expression::ArrayConstructor)
    result = val[1]
  else
    result = ast Expression::ArrayConstructor, :children => [val[1]]
  end
}           | LBRACK RBRACK {
  result = ast Expression::ArrayConstructor
}

comma:        FARROW
  | COMMA

endcomma:     # nothing
  | COMMA { result = nil }

regex:        REGEX {
  result = ast Expression::Regex, :value => val[0][:value]
}

hash:        LBRACE hashpairs RBRACE {
  if val[1].instance_of?(Expression::HashConstructor)
    result = val[1]
  else
    result = ast Expression::HashConstructor, { :value => val[1] }
  end
}
  | LBRACE hashpairs COMMA RBRACE {
    if val[1].instance_of?(Expression::HashConstructor)
    result = val[1]
  else
    result = ast Expression::HashConstructor, { :value => val[1] }
  end
}           | LBRACE RBRACE {
  result = ast Expression::HashConstructor
}

hashpairs:  hashpair
  | hashpairs COMMA hashpair {
    if val[0].instance_of?(Expression::HashConstructor)
    result = val[0].merge(val[2])
  else
    result = ast Expression::HashConstructor, :value => val[0]
    result.merge(val[2])
  end
}

hashpair:   key FARROW rvalue {
  result = ast Expression::HashConstructor, { :value => { val[0] => val[2] } }
}

key:   NAME { result = val[0][:value] }
  | STRING { result = val[0][:value] }

hasharrayaccess: VARIABLE LBRACK rvalue RBRACK {
  result = ast Expression::HashOrArrayAccess, :variable => val[0][:value], :key => val[2]
}

hasharrayaccesses:    hasharrayaccess
  | hasharrayaccess LBRACK rvalue RBRACK {
    result = ast Expression::HashOrArrayAccess, :variable => val[0], :key => val[2]
}

end
---- header ----
require 'puppet'
require 'puppet/util/loadedfile'
require 'puppet/parser/lexer'
require 'puppet/parser/expression'

module Puppet
  class ParseError < Puppet::Error; end
  class ImportError < Racc::ParseError; end
  class AlreadyImportedError < ImportError; end
end

---- inner ----

# It got too annoying having code in a file that needs to be compiled.
require 'puppet/parser/parser_support'

# Make emacs happy
# Local Variables:
# mode: ruby
# End:

# $Id$

